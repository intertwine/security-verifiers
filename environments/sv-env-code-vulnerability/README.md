# Vulnerability Repair in Code

Security Verifiers environment for **patch-and-test vulnerability remediation** (Environment E3 in the
[PRD](../../PRD.md)). The environment now executes a full loop: generate a unified diff, apply the patch to
the vulnerable snippet, run security-focused regression tests, and score the result.

## Overview

- **Task**: Given a vulnerable Python helper, return a JSON object describing the patch, test outcome, and security rationale.
- **Schema**:

  ```json
  {
    "diff": "unified diff string",
    "tests_passed": true,
    "explanation": "short natural-language summary",
    "patched_code": "optional full code listing"
  }
  ```

- **Tools**:
  - `run_python_static_scan`: heuristic SAST signal for risky constructs (AST-backed SQL concatenation detection, unsafe YAML loading, insecure randomness).
  - `run_patch_and_tests`: apply a diff or patched code, execute behavior + security checks inside a sandboxed runtime, and report pass/fail.

- **Reward** (`reward_patch_and_test`):
  - 60% from executing the regression suite (must pass).
  - 20% from similarity between submitted diff and reference patch.
  - 10% from consistency between claimed `tests_passed` and executor result.
  - 10% from covering reference explanation keywords.

## Dataset

The first working release ships a curated synthetic dataset with executable examples:

| ID | Vulnerability | Required Fix | Regression Focus |
| --- | --- | --- | --- |
| `sql_injection_parameterization` | f-string SQL concatenation | Return `(query, params)` tuple using placeholders | Parameterised queries and placeholder presence |
| `yaml_safe_load` | `yaml.load` with `FullLoader` | Switch to `yaml.safe_load` while preserving benign parsing | Benign config parse + malicious payload rejection |

Each example stores the vulnerable source, canonical patch, and a machine-executable `test_spec`. The environment loads
these as a `datasets.Dataset`, so evaluation is deterministic and tool-friendly.

### Example Prompt

````text
You are securing a Python helper that builds SQL queries. Patch the vulnerability and return JSON with fields
"diff", "tests_passed", "explanation", and optional "patched_code".

Vulnerable implementation:
```python
def build_query(username: str) -> str:
    """Return a SQL query for the supplied username."""

    return f"SELECT * FROM users WHERE name = '{username}'"
```

Requirements:
- Return a parameterized query string alongside a tuple of parameters.
- Ensure suspicious usernames do not appear directly embedded in the SQL string.
- Keep the function signature unchanged.
````

### Example Output

```json
{
  "diff": "--- query.py\n+++ query.py\n@@ -1,4 +1,6 @@\n-def build_query(username: str) -> str:\n-    \"\"\"Return a SQL query for the supplied username.\"\"\"\n-\n-    return f\"SELECT * FROM users WHERE name = '{username}'\"\n+def build_query(username: str) -> tuple[str, tuple[str, ...]]:\n+    \"\"\"Return a parameterized SQL query and parameters.\"\"\"\n+\n+    query = \"SELECT * FROM users WHERE name = ?\"\n+    params = (username,)\n+    return query, params\n",
  "tests_passed": true,
  "explanation": "The query is parameterized and no longer concatenates user input.",
  "patched_code": "def build_query(..." 
}
```

## Implementation Notes

- **Parser**: `CodeVulnerabilityParser` enforces JSON schema compliance and exposes a format reward for tidy answers.
- **Patch Executor**: `apply_unified_diff` relies on `unidiff.PatchSet` to parse unified diffs before patching, rejecting malformed or multi-file patches early.
- **Testing Harness**: `run_patch_and_tests` executes deterministic behavioural & security checks from `test_spec`
  (e.g. parameter tuple equality, exception expectations for malicious payloads, token placeholder enforcement).
- **Sandbox**: Patched code is validated with the Python AST, allowed imports are whitelisted, and execution runs with a read-only builtins mapping to constrain effects.
- **Environment**: `load_environment` builds a `vf.ToolEnv` with the dataset, tools, parser, rubric, and system prompt.

## Running Tests

```bash
uv run pytest environments/sv-env-code-vulnerability/sv_env_code_vulnerability_test.py
```

This exercises parser behaviour, static scan heuristics, diff application, the patch-and-test loop, reward shaping, and loader wiring.

## Installation

Install in editable mode from the repository root:

```bash
uv pip install -e environments/sv-env-code-vulnerability
```

## Safety

- Only trusted, synthetic snippets are executed.
- The executor validates patched code (AST inspection + import allowlist) and runs with restricted builtins, preventing `eval`, `open`, and other dangerous primitives.
- Expansion to external datasets should keep this safety profile (sandboxing, timeouts) before execution is enabled.

## Related Docs

- [EXECUTIVE_SUMMARY.md](../../EXECUTIVE_SUMMARY.md) – project overview.
- [PRD.md](../../PRD.md) – specification for all Security Verifiers environments.
