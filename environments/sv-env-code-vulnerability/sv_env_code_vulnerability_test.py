"""Tests for the sv-env-code-vulnerability environment."""

from __future__ import annotations

import difflib
import json
import textwrap

import pytest
import verifiers as vf

from sv_env_code_vulnerability import (
    CodeVulnerabilityParser,
    apply_unified_diff,
    load_environment,
    reward_patch_and_test,
    run_patch_and_tests,
    run_python_static_scan,
)


@pytest.fixture
def sql_injection_example() -> dict:
    """Example dataset entry for SQL injection mitigation."""

    vulnerable_code = textwrap.dedent(
        '''
        def build_query(username: str) -> str:
            """Return a SQL query for the supplied username."""

            return f"SELECT * FROM users WHERE name = '{username}'"
        '''
    ).strip()

    patched_code = textwrap.dedent(
        '''
        def build_query(username: str) -> tuple[str, tuple[str, ...]]:
            """Return a parameterized SQL query and parameters."""

            query = "SELECT * FROM users WHERE name = ?"
            params = (username,)
            return query, params
        '''
    ).strip()

    diff = "\n".join(
        difflib.unified_diff(
            vulnerable_code.splitlines(),
            patched_code.splitlines(),
            fromfile="query.py",
            tofile="query.py",
            lineterm="",
        )
    )

    test_spec = {
        "entrypoint": "build_query",
        "behavioral_tests": [
            {
                "args": ["alice"],
                "expected": {
                    "query": "SELECT * FROM users WHERE name = ?",
                    "params": ("alice",),
                },
            }
        ],
        "security_tests": [
            {
                "args": ["bob' OR '1'='1"],
                "expected": {
                    "query": "SELECT * FROM users WHERE name = ?",
                    "params": ("bob' OR '1'='1",),
                },
            }
        ],
        "required_substrings_in_code": ["?"],
        "forbidden_substrings_in_code": ["%", "+"],
    }

    return {
        "id": "sql_injection_parameterization",
        "language": "python",
        "original_code": vulnerable_code,
        "patched_code": patched_code,
        "expected_diff": diff,
        "test_spec": test_spec,
        "expected_tests_passed": True,
        "explanation_keywords": ["parameterized", "parameters"],
    }


@pytest.fixture
def unsafe_yaml_example() -> dict:
    """Example dataset entry for unsafe YAML loading mitigation."""

    vulnerable_code = textwrap.dedent(
        '''
        import yaml


        def load_config(document: str):
            """Load YAML configuration without safety checks."""

            return yaml.load(document, Loader=yaml.FullLoader)
        '''
    ).strip()

    patched_code = textwrap.dedent(
        '''
        import yaml


        def load_config(document: str):
            """Safely load YAML configuration using safe_load."""

            return yaml.safe_load(document)
        '''
    ).strip()

    diff = "\n".join(
        difflib.unified_diff(
            vulnerable_code.splitlines(),
            patched_code.splitlines(),
            fromfile="config.py",
            tofile="config.py",
            lineterm="",
        )
    )

    test_spec = {
        "entrypoint": "load_config",
        "behavioral_tests": [
            {
                "args": ["debug: false"],
                "expected": {"debug": False},
            }
        ],
        "security_tests": [
            {
                "args": ["!!python/object/apply:os.system ['echo unsafe']"],
                "raises": True,
            }
        ],
        "required_substrings_in_code": ["safe_load"],
        "forbidden_substrings_in_code": ["yaml.load"],
    }

    return {
        "id": "yaml_safe_load",
        "language": "python",
        "original_code": vulnerable_code,
        "patched_code": patched_code,
        "expected_diff": diff,
        "test_spec": test_spec,
        "expected_tests_passed": True,
        "explanation_keywords": ["safe_load", "unsafe", "yaml"],
    }


def test_python_static_scan_detects_injection(sql_injection_example: dict) -> None:
    """Static scan should flag SQL string concatenation vulnerabilities."""

    report = run_python_static_scan(sql_injection_example["original_code"])

    assert report["verdict"] == "Vulnerable"
    assert any("SQL" in finding for finding in report["vulnerabilities"])


def test_apply_unified_diff_round_trip(sql_injection_example: dict) -> None:
    """Applying the diff should recreate the patched code."""

    patched = apply_unified_diff(
        sql_injection_example["original_code"],
        sql_injection_example["expected_diff"],
    )

    assert patched is not None
    assert patched.strip() == sql_injection_example["patched_code"].strip()


def test_run_patch_and_tests_success(sql_injection_example: dict) -> None:
    """Patch runner should execute behavioral and security tests."""

    result = run_patch_and_tests(
        original_code=sql_injection_example["original_code"],
        diff=sql_injection_example["expected_diff"],
        test_spec=sql_injection_example["test_spec"],
    )

    assert result["tests_passed"] is True
    assert result["failures"] == []


def test_run_patch_and_tests_failure(sql_injection_example: dict) -> None:
    """Supplying the vulnerable code should cause the tests to fail."""

    result = run_patch_and_tests(
        original_code=sql_injection_example["original_code"],
        patched_code=sql_injection_example["original_code"],
        test_spec=sql_injection_example["test_spec"],
    )

    assert result["tests_passed"] is False
    assert any("parameterized" in failure.lower() for failure in result["failures"])


def test_parser_parses_and_rewards_format(sql_injection_example: dict) -> None:
    """Parser should extract JSON fields and format reward should reflect compliance."""

    parser = CodeVulnerabilityParser()

    completion = json.dumps(
        {
            "diff": sql_injection_example["expected_diff"],
            "tests_passed": True,
            "explanation": "The query is now parameterized using placeholders and parameters.",
            "patched_code": sql_injection_example["patched_code"],
        }
    )

    parsed = parser.parse_answer(completion)

    assert parsed["tests_passed"] is True
    assert "parameterized" in parsed["explanation"].lower()

    format_reward = parser.get_format_reward_func()
    assert format_reward(completion) == 1.0
    assert format_reward("not json") == 0.0


def test_reward_patch_and_test(sql_injection_example: dict) -> None:
    """Reward should be high for correct fixes and low for incorrect ones."""

    good_completion = json.dumps(
        {
            "diff": sql_injection_example["expected_diff"],
            "tests_passed": True,
            "explanation": "The query is parameterized and avoids direct string concatenation.",
            "patched_code": sql_injection_example["patched_code"],
        }
    )

    reward = reward_patch_and_test(good_completion, sql_injection_example)
    assert reward > 0.8

    bad_completion = json.dumps(
        {
            "diff": "",
            "tests_passed": True,
            "explanation": "Everything is already safe.",
            "patched_code": sql_injection_example["original_code"],
        }
    )

    bad_reward = reward_patch_and_test(bad_completion, sql_injection_example)
    assert bad_reward < 0.4


def test_reward_handles_security_regressions(unsafe_yaml_example: dict) -> None:
    """Reward function should penalize patches that keep unsafe loaders."""

    regression_completion = json.dumps(
        {
            "diff": unsafe_yaml_example["expected_diff"],
            "tests_passed": True,
            "explanation": "yaml.safe_load is used to avoid executing arbitrary objects.",
            "patched_code": unsafe_yaml_example["original_code"],
        }
    )

    reward = reward_patch_and_test(regression_completion, unsafe_yaml_example)
    assert reward < 0.5


def test_load_environment_creates_tool_env() -> None:
    """Environment loader should assemble dataset, tools, and rubric."""

    env = load_environment(max_examples=2)

    assert isinstance(env, vf.ToolEnv)
    assert len(env.dataset) == 2
    example = env.dataset[0]

    assert "diff" in env.system_prompt.lower()
    assert isinstance(example["answer"], dict)
    assert "test_spec" in example["answer"]
    assert len(env.tools) == 2
